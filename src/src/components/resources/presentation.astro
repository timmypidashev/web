// src/components/resources/presentation.astro
<button id="presentation-button" class="presentation-hidden" type="button"
  >Start Presentation</button
>

<div class="presentation-progress"></div>

<script>
  const button = document.getElementById(
    "presentation-button"
  ) as HTMLButtonElement;

  let slides = Array.from(document.querySelectorAll(".presentation-slide"));

  let slide = 0;
  let step = 0; // Current step within the slide
  let presenter = false;

  const presentationId = window.location.href;

  const nextSlide = () => {
    if (slide === slides.length - 1) {
      return slide;
    }
    return slide + 1;
  };

  const prevSlide = () => {
    if (slide === 0) {
      return slide;
    }
    return slide - 1;
  };

  const nextClass = "presentation-next";
  const currClass = "presentation-current";
  const prevClass = "presentation-prev";

  const transitionClasses = [nextClass, currClass, prevClass];

  // Animation classes for step-through content
  const animationClasses = {
    'fade-in': 'animate-fade-in-step',
    'slide-in-left': 'animate-slide-in-left-step',
    'slide-in-right': 'animate-slide-in-right-step',
    'slide-in-up': 'animate-slide-in-up-step',
    'slide-in-down': 'animate-slide-in-down-step',
    'type-in': 'animate-type-in-step',
    'scale-in': 'animate-scale-in-step',
    'bounce-in': 'animate-bounce-in-step'
  };

  const getCurrentSlideSteps = () => {
    const currentSlide = slides[slide];
    return Array.from(currentSlide.querySelectorAll('[step]'))
      .sort((a, b) => {
        const stepA = parseInt((a as HTMLElement).getAttribute('step') || '0');
        const stepB = parseInt((b as HTMLElement).getAttribute('step') || '0');
        return stepA - stepB;
      });
  };

  const getMaxSteps = () => {
    const steps = getCurrentSlideSteps();
    if (steps.length === 0) return 0;
    const lastStep = steps[steps.length - 1] as HTMLElement;
    return parseInt(lastStep.getAttribute('step') || '0');
  };

  const showStepsUpTo = (targetStep: number, isReverse: boolean = false) => {
    const steps = getCurrentSlideSteps();
    
    steps.forEach((stepElement) => {
      const element = stepElement as HTMLElement;
      const elementStep = parseInt(element.getAttribute('step') || '0');
      const animationType = element.getAttribute('animation') || 'fade-in';
      
      // Remove all animation classes first
      Object.values(animationClasses).forEach(cls => {
        element.classList.remove(cls);
        element.classList.remove(cls.replace('-step', '-reverse-step'));
      });
      element.classList.remove('step-hidden', 'step-visible');
      
      if (elementStep <= targetStep) {
        // Show this step with animation
        element.classList.add('step-visible');
        if (elementStep === targetStep) {
          // Apply animation only to the current step
          const baseAnimationClass = animationClasses[animationType as keyof typeof animationClasses] || animationClasses['fade-in'];
          const animationClass = isReverse ? baseAnimationClass.replace('-step', '-reverse-step') : baseAnimationClass;
          
          // Special handling for type-in animation
          if (animationType === 'type-in') {
            if (isReverse) {
              startTypeAnimation(element, false);
            } else {
              startTypeAnimation(element, true);
            }
          } else {
            element.classList.add(animationClass);
          }
        }
      } else {
        // Hide this step
        element.classList.add('step-hidden');
      }
    });
  };

  const startTypeAnimation = (element: HTMLElement, isForward: boolean) => {
    const text = element.textContent || '';
    const duration = isForward ? 1500 : 1000; // ms
    const steps = Math.max(text.length, 1);
    const stepDuration = duration / steps;
    
    if (isForward) {
      // Type in: reveal characters one by one
      element.textContent = '';
      element.style.opacity = '1';
      
      let currentIndex = 0;
      const typeInterval = setInterval(() => {
        if (currentIndex < text.length) {
          element.textContent = text.substring(0, currentIndex + 1);
          currentIndex++;
        } else {
          clearInterval(typeInterval);
        }
      }, stepDuration);
      
      // Store interval reference for cleanup
      (element as any)._typeInterval = typeInterval;
    } else {
      // Type out: hide characters one by one from the end
      let currentLength = text.length;
      const typeInterval = setInterval(() => {
        if (currentLength > 0) {
          element.textContent = text.substring(0, currentLength - 1);
          currentLength--;
        } else {
          clearInterval(typeInterval);
          element.style.opacity = '0';
        }
      }, stepDuration);
      
      // Store interval reference for cleanup
      (element as any)._typeInterval = typeInterval;
    }
  };

  const resetSlideSteps = () => {
    const steps = getCurrentSlideSteps();
    steps.forEach((stepElement) => {
      const element = stepElement as HTMLElement;
      
      // Clear any running type animations
      if ((element as any)._typeInterval) {
        clearInterval((element as any)._typeInterval);
        (element as any)._typeInterval = null;
      }
      
      Object.values(animationClasses).forEach(cls => {
        element.classList.remove(cls);
        element.classList.remove(cls.replace('-step', '-reverse-step'));
      });
      element.classList.remove('step-hidden', 'step-visible');
      element.classList.add('step-hidden');
      
      // Reset text content and styles for type-in elements
      if (element.getAttribute('animation') === 'type-in') {
        element.style.opacity = '0';
      }
    });
  };

  const nextStep = () => {
    const maxSteps = getMaxSteps();
    
    if (step < maxSteps) {
      step++;
      showStepsUpTo(step, false);
      return { slide, step };
    } else {
      // Move to next slide
      if (slide < slides.length - 1) {
        const nextSlideIndex = nextSlide();
        return { slide: nextSlideIndex, step: 0 };
      }
      return { slide, step };
    }
  };

  const prevStep = () => {
    if (step > 0) {
      step--;
      showStepsUpTo(step, true);
      return { slide, step };
    } else {
      // Move to previous slide
      if (slide > 0) {
        const prevSlideIndex = prevSlide();
        // Set to max steps of previous slide
        const tempSlide = slide;
        slide = prevSlideIndex;
        const maxSteps = getMaxSteps();
        slide = tempSlide;
        return { slide: prevSlideIndex, step: maxSteps };
      }
      return { slide, step };
    }
  };

  const keyHandlers: Record<string, () => { slide: number, step: number }> = {
    ArrowRight: nextStep,
    ArrowLeft: prevStep,
  };

  const displaySlides = () => {
    for (let i = 0; i < slides.length; i++) {
      slides[i].classList.remove("active", "inactive", ...transitionClasses);

      if (i === slide) {
        slides[i].classList.add("active", currClass);
        // Show steps for current slide
        showStepsUpTo(step, false);
      } else {
        slides[i].classList.add("inactive");
        // Reset steps for non-current slides
        const tempSlide = slide;
        slide = i;
        resetSlideSteps();
        slide = tempSlide;

        if (i > slide) {
          slides[i].classList.add(nextClass);
        } else {
          slides[i].classList.add(prevClass);
        }
      }
    }
  };

  let presenting = false;
  const startPresentation = () => {
    button.innerHTML = "Resume presentation";
    document.body.classList.add("presentation-overflow-hidden");

    presenting = true;
    step = 0; // Reset step
    displaySlides();
    setProgress();
    initListeners();
  };

  const endPresentation = () => {
    document.body.classList.remove("presentation-overflow-hidden");

    presenting = false;
    step = 0;
    slides.map((s) => {
      s.classList.remove("active", "inactive", ...transitionClasses);
      // Reset all steps
      const tempSlide = slide;
      slides.forEach((_, i) => {
        slide = i;
        resetSlideSteps();
      });
      slide = tempSlide;
    });
  };

  const setPresenter = () => {
    presenter = true;
    document.body.classList.add("presentation-presenter");
  };

  const setProgress = () => {
    const maxSteps = getMaxSteps();
    const totalSteps = slides.reduce((acc, _, i) => {
      const tempSlide = slide;
      slide = i;
      const steps = getMaxSteps();
      slide = tempSlide;
      return acc + Math.max(1, steps);
    }, 0);
    
    let currentProgress = 0;
    for (let i = 0; i < slide; i++) {
      const tempSlide = slide;
      slide = i;
      const steps = getMaxSteps();
      slide = tempSlide;
      currentProgress += Math.max(1, steps);
    }
    currentProgress += step;
    
    const progress = (currentProgress / totalSteps) * 100;
    document.body.style.setProperty('--presentation-progress', `${progress}%`);
  };

  const transition = (nextSlide: number, nextStep: number = 0) => {
    if (!presenting) {
      return;
    }

    if (slide === nextSlide && step === nextStep) {
      return;
    }

    slides.forEach((s) => s.classList.remove(...transitionClasses));

    slide = nextSlide;
    step = nextStep;

    displaySlides();
    setProgress();
  };

  let listenersInitialized = false;
  const initListeners = () => {
    if (listenersInitialized) {
      return;
    }

    listenersInitialized = true;
    window.addEventListener("keyup", (ev) => {
      ev.preventDefault();
      const isEscape = ev.key === "Escape";
      if (isEscape) {
        endPresentation();
        return;
      }

      const isSpace = ev.key === " ";
      if (isSpace) {
        setPresenter();
        return;
      }

      const getNextPosition = keyHandlers[ev.key];

      if (!getNextPosition) {
        return;
      }

      const { slide: nextSlideIndex, step: nextStepIndex } = getNextPosition();
      transition(nextSlideIndex, nextStepIndex);
    });

    let touchstartX = 0;
    let touchendX = 0;
    const handleGesture = () => {
      const magnitude = Math.abs(touchstartX - touchendX);

      if (magnitude < 40) {
        // Ignore since this could be a scroll up/down
        return;
      }

      if (touchendX < touchstartX) {
        const { slide: nextSlideIndex, step: nextStepIndex } = nextStep();
        transition(nextSlideIndex, nextStepIndex);
      }
      if (touchendX > touchstartX) {
        const { slide: prevSlideIndex, step: prevStepIndex } = prevStep();
        transition(prevSlideIndex, prevStepIndex);
      }
    };

    document.addEventListener(
      "touchstart",
      (ev) => {
        touchstartX = ev.changedTouches[0].screenX;
      },
      false
    );

    document.addEventListener(
      "touchend",
      (event) => {
        touchendX = event.changedTouches[0].screenX;
        handleGesture();
      },
      false
    );
  };

  // If there is no presentation on the page then we don't initialize
  if (slides.length) {
    button.classList.remove("presentation-hidden");
    button.addEventListener("click", startPresentation);
  }
</script>

<style is:global>
  .presentation-progress {
    display: none;
  }

  /* Step animation styles */
  .step-hidden {
    opacity: 0;
    visibility: hidden;
  }

  .step-visible {
    opacity: 1;
    visibility: visible;
  }

  /* Animation keyframes */
  @keyframes fadeInStep {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  @keyframes fadeOutStep {
    from {
      opacity: 1;
    }
    to {
      opacity: 0;
    }
  }

  @keyframes slideInLeftStep {
    from {
      opacity: 0;
      transform: translateX(-30px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  @keyframes slideOutLeftStep {
    from {
      opacity: 1;
      transform: translateX(0);
    }
    to {
      opacity: 0;
      transform: translateX(-30px);
    }
  }

  @keyframes slideInRightStep {
    from {
      opacity: 0;
      transform: translateX(30px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  @keyframes slideOutRightStep {
    from {
      opacity: 1;
      transform: translateX(0);
    }
    to {
      opacity: 0;
      transform: translateX(30px);
    }
  }

  @keyframes slideInUpStep {
    from {
      opacity: 0;
      transform: translateY(30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes slideOutUpStep {
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(30px);
    }
  }

  @keyframes slideInDownStep {
    from {
      opacity: 0;
      transform: translateY(-30px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes slideOutDownStep {
    from {
      opacity: 1;
      transform: translateY(0);
    }
    to {
      opacity: 0;
      transform: translateY(-30px);
    }
  }

  @keyframes scaleInStep {
    from {
      opacity: 0;
      transform: scale(0.8);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  @keyframes scaleOutStep {
    from {
      opacity: 1;
      transform: scale(1);
    }
    to {
      opacity: 0;
      transform: scale(0.8);
    }
  }

  @keyframes bounceInStep {
    0% {
      opacity: 0;
      transform: scale(0.3);
    }
    50% {
      opacity: 1;
      transform: scale(1.05);
    }
    70% {
      transform: scale(0.9);
    }
    100% {
      opacity: 1;
      transform: scale(1);
    }
  }

  @keyframes bounceOutStep {
    0% {
      opacity: 1;
      transform: scale(1);
    }
    30% {
      transform: scale(1.05);
    }
    50% {
      opacity: 1;
      transform: scale(0.9);
    }
    100% {
      opacity: 0;
      transform: scale(0.3);
    }
  }

  @keyframes typeInStep {
    /* This is now unused - keeping for backward compatibility */
    from { opacity: 1; }
    to { opacity: 1; }
  }

  @keyframes typeOutStep {
    /* This is now unused - keeping for backward compatibility */
    from { opacity: 1; }
    to { opacity: 1; }
  }

  /* Animation classes */
  .animate-fade-in-step {
    animation: fadeInStep 0.6s ease-out forwards;
  }

  .animate-fade-in-reverse-step {
    animation: fadeOutStep 0.6s ease-out forwards;
  }

  .animate-slide-in-left-step {
    animation: slideInLeftStep 0.6s ease-out forwards;
  }

  .animate-slide-in-left-reverse-step {
    animation: slideOutLeftStep 0.6s ease-out forwards;
  }

  .animate-slide-in-right-step {
    animation: slideInRightStep 0.6s ease-out forwards;
  }

  .animate-slide-in-right-reverse-step {
    animation: slideOutRightStep 0.6s ease-out forwards;
  }

  .animate-slide-in-up-step {
    animation: slideInUpStep 0.6s ease-out forwards;
  }

  .animate-slide-in-up-reverse-step {
    animation: slideOutUpStep 0.6s ease-out forwards;
  }

  .animate-slide-in-down-step {
    animation: slideInDownStep 0.6s ease-out forwards;
  }

  .animate-slide-in-down-reverse-step {
    animation: slideOutDownStep 0.6s ease-out forwards;
  }

  .animate-scale-in-step {
    animation: scaleInStep 0.6s ease-out forwards;
  }

  .animate-scale-in-reverse-step {
    animation: scaleOutStep 0.6s ease-out forwards;
  }

  .animate-bounce-in-step {
    animation: bounceInStep 0.8s ease-out forwards;
  }

  .animate-bounce-in-reverse-step {
    animation: bounceOutStep 0.8s ease-out forwards;
  }

  .animate-type-in-step {
    /* JavaScript-controlled animation - no CSS animation needed */
  }

  .animate-type-in-reverse-step {
    /* JavaScript-controlled animation - no CSS animation needed */
  }

  .presentation-overflow-hidden {
    overflow: hidden;
    visibility: hidden;

    .presentation-hidden {
      display: none;
    }

    h1, h2, h3, h4 {
      font-size: xx-large;
    }

    .presentation-slide.large {
        font-size: x-large;
    }

    .presentation-progress {
      transition: width 1000ms;
      display: block;
      visibility: visible;
      position: absolute;
      z-index: 20;
      top:0px;
      left: 0px;
      width: var(--presentation-progress);
      height: .25rem;
      background: var(--color-brand-muted);
    }

    .presentation-slide {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;

      visibility: visible;

      transition: transform 300ms ease-in-out;

      display: flex;
      flex-direction: column;

      background-color: var(--color-base);
      color: var(--color-on-base);

      box-sizing: border-box;
      min-height: 100vh;
      width: 100%;
      padding: 2rem 4rem;

      z-index: 10;
      overflow: auto;

      &.centered {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      &.highlight{
        background-color: var(--color-brand);
        color: var(--color-on-brand)
      }

      .presentation-slide-only {
        display: block;
      }

      .astro-code {
        filter: none;
      }

      img {
        max-height: 80vh;
      }

    }

    &.presentation-presenter {
      .presentation-slide {
        border: none;
        border-bottom: solid 8px var(--color-brand);
      }

      .presentation-note {
        position: absolute;
        bottom: 24px;
        opacity: .8;
        right: 24px;
        left: 25%;
        z-index: 999;
      }
    }
  }

  .presentation-slide-only {
    display: none;
  }

  .presentation-next {
    transform: translateX(100%);
  }

  .presentation-current {
    transform: translateX(0%);
  }

  .presentation-prev {
    transform: translateX(-100%);
  }

  .presentation-note {
    display: none;
  }

  .presentation-presenter {
    .presentation-slide {
      border: dotted 8px var(--color-brand);
    }

    /* ensure that notes are visible if presentation mode is active, even if
    not presenting */
    .presentation-note {
      display: block;
      /* intentionally obnoxios color to draw attention */
      background-color: crimson;
      padding: 24px;
      color: white;
      font-size: xx-large;
    }
  }
</style>
